(ns dang.evaluate
  (:require
   [meander.epsilon :as m]))

(def z-ast
  '[:lam f ::ignore
    [:app
     [:lam x ::ignore [:app f [:lam v ::ignore [:app x [:app x v]]]]]
     [:lam x ::ignore [:app f [:lam v ::ignore [:app x [:app x v]]]]]]])

(defn- evaluate-ctx
  [expr ctx]
  (let [eval-curr #(evaluate-ctx % ctx)]
    (m/match expr

      (m/symbol _ _ :as ?sym)
      (get ctx ?sym [::symbol-not-found ctx ?sym])

      [:if-then-else ?cond ?if-body ?else-body]
      (if (eval-curr ?cond)
        (eval-curr ?if-body)
        (eval-curr ?else-body))

      [:app :dang.ast/is-zero ?arg] (= 0 (eval-curr ?arg))

      [:app :dang.ast/succ ?arg] (+ 1 (eval-curr ?arg))

      [:app :dang.ast/pred ?arg] (max 0 (- (eval-curr ?arg) 1))

      ;; sugar for app over lam
      [:let ?name ?binding ?body]
      (eval-curr
       [:app [:lam ?name ::ignore ?body] ?binding])

      ;; app's first arg is anything that evaluates to a lambda
      [:app (m/app eval-curr [:lam ?name _ ?body]) ?arg]
      (evaluate-ctx
       ?body
       (assoc ctx ?name (eval-curr ?arg)))

      ;; sugar for applying the Z combinator
      [:fix ?lambda]
      (eval-curr [:app z-ast ?lambda])

      ?otherwise ?otherwise)))



(defn evaluate
  "evaluate the ast generated by dang.parser into either
   
   a number
   
   a boolean
   
   a lambda
   
   or nil, if a type or logic error occurs"
  [expr] (evaluate-ctx expr {}))

(comment
  (evaluate [:app :dang.ast/is-zero 0])
  (evaluate [:app :dang.ast/succ 1])
  (evaluate [:if-then-else false 1 0])
  (evaluate [:app [:lam 'foo :dang.ast/nat 'foo] 0])
  (evaluate [:let 'foo 32 [:app :dang.ast/succ 'foo]])
  (evaluate [:app [:lam 'foo ::ignore 32] true])
  (evaluate [:fix [:lam 'x :dang.ast/nat 1]]))