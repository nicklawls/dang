(ns dang.evaluate
  (:require
   [meander.epsilon :as m]
   [meander.strategy.epsilon :as r]))

(def z-ast
  '[:lam f ::idk
    [:app
     [:lam x ::idk [:app f [:lam v ::idk [:app x [:app x v]]]]]
     [:lam x ::idk [:app f [:lam v ::idk [:app x [:app x v]]]]]]])

(defn- evaluate-ctx
  [expr ctx]
  (m/match expr

    (m/symbol _ _ :as ?sym)
    (get ctx ?sym [::symbol-not-found ctx ?sym])

    [:if-then-else ?cond ?if-body ?else-body]
    (if (evaluate-ctx ?cond ctx)
      (evaluate-ctx ?if-body ctx)
      (evaluate-ctx ?else-body ctx))

    [:app :dang.ast/is-zero ?arg] (= 0 (evaluate-ctx ?arg ctx))

    [:app :dang.ast/succ ?arg] (+ 1 (evaluate-ctx ?arg ctx))

    [:app :dang.ast/pred ?arg] (max 0 (- (evaluate-ctx ?arg ctx) 1))

    ;; sugar for app over lam
    [:let ?name ?binding ?body]
    (evaluate-ctx
     [:app [:lam ?name ::ignore ?body] ?binding]
     ctx)

    ;; app's first arg is anything that evaluates to a lambda: symbol or lambda
    [:app (m/app #(evaluate-ctx % ctx) [:lam ?name _ ?body]) ?arg]
    (evaluate-ctx
     ?body
     (assoc ctx ?name (evaluate-ctx ?arg ctx)))

    ;; sugar for applying the Z combinator
    [:fix ?lambda]
    (evaluate-ctx [:app z-ast ?lambda] ctx)

    ?otherwise ?otherwise))



(defn evaluate
  "evaluate the ast generated by dang.parser into either
   
   a number
   
   a boolean
   
   a lambda
   
   or nil, if a type or logic error occurs"
  [expr] (evaluate-ctx expr {}))

(comment
  (evaluate [:app :dang.ast/is-zero 0])
  (evaluate [:app :dang.ast/succ 1])
  (evaluate [:if-then-else false 1 0])
  (evaluate [:app [:lam 'foo :dang.ast/nat 'foo] 0])
  (evaluate [:let 'foo 32 [:app :dang.ast/succ 'foo]])
  (evaluate [:app [:lam 'foo ::idk 32] true])
  (evaluate [:fix [:lam 'x :dang.ast/nat 1]]))